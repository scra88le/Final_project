```{r load_libs_for_imp_grassland, message=FALSE, warning=FALSE, include=FALSE}
library(sf)
library(raster)
library(tidymodels)
library(tidyverse)
library(RStoolbox)
```

## Improved grassland classification

The results below detail how remotely sensed satellite data was processed using a Support Vector Machine to generate a classification for improved grassland across the various islands of Shetland.

### Shetland Sentinel 2 satelitte dataset

A Sentinel 2 satellite spatial dataset was clipped using the Integrated Administration And Control System (IACS) field boundary shapefile for Shetland. This gave a spatial dataset comprising of land-based habitat only, excluding built areas and roads, as shown in Figure \@ref(fig:plotSentRGB)  

```{r loadSentinelImg, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# 2020 July Product
sent = list.files("~/Documents/GitHub/shetlandwaders/data/shetland_sentinel/", 
                  pattern = ".tiff", 
                  full.names = TRUE)
# Create raster stack
sent = stack(sent)

# Sentinel 2 Bands, central wavelength(micrometre), all at 10m resolution
sat_bands <- c('aerosol',   # Band 1 - Coastal aerosol (0.443)
               'blue',      # Band 2 - Blue (0.490)
               'green',     # Band 3 - Green (0.560)
               'red',       # Band 4 - Red (0.665)
               'veg_red1',  # Band 5 - Vegetation Red Edge (0.705)    
               'veg_red2',  # Band 6 - Vegetation Red Edge (0.740)
               'veg_red3',  # Band 7 - Vegetation Red Edge (0.783)
               'NIR',       # Band 8 - NIR (0.842)
               'veg_red4',  # Band 8A - Vegetation Red Edge (0.865)
               'SWIR1',     # Band 11 - SWIR1 (1.610)
               'SWIR2')     # Band 12 - SWIR 2 (2.190)

# Name the layers
names(sent) <- sat_bands
# Convert to brick for faster processing
sent <- brick(sent)

# Projection for 27700 (OSGB) - this takes a long time!
osgb36_proj <- "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs"
sent <- projectRaster(sent, crs=osgb36_proj)
# Get raster extent
e <- raster::extent(sent)

# Load IACS field boundaries
iacs_sf <- st_read("~/Documents/GitHub/shetlandwaders/data/IACS_Shetland/IACS_Shetland_polygon.shp",quiet=TRUE) 
iacs_sp <- as_Spatial(iacs_sf)
# Crop the iacs field boundaries to the raster extent
shet_iacs_sp <- crop(iacs_sp,e)
# Mask out all habitat not covered by the cropped iacs polygons 
shet_r <- raster::mask(sent, shet_iacs_sp)

```

```{r plotSentRGB, echo=FALSE, message=FALSE, warning=FALSE,fig.align='center', fig.asp=1.2, fig.cap='Clipped Sentinel 2 RGB composite of Shetland'}
# Load processed sentinel image
shet_r <- stack("~/Documents/GitHub/shetlandwaders/data/cacheddata/shet_raster.grd")
  # Plot Sentinel RGB image
RStoolbox::ggRGB(img = shet_r,
      r = 4,
      g = 3,
      b = 2,
      stretch = 'lin')
```


```{r load_land_categories, eval=FALSE, warning=FALSE, include=FALSE}
set.seed(123)
training_df <- st_read("~/Documents/GitHub/shetlandwaders/data/training_data_classification/Training_samples.shp",crs=27700, quiet=TRUE) %>%
  mutate(class = case_when(
    Habitat == "Improved"    ~ 1,
    Habitat == "Unimproved"  ~ 2,
    Habitat == "Upland"      ~ 3,
    Habitat == "Bare peat"   ~ 4,
    Habitat == "Crop"        ~ 5,
    Habitat == "Cliff"       ~ 6)
    ) %>%
  # Dump the columns we dont need
  dplyr::select(-Id, -Habitat) %>%
  # Sample 100 points from each class
  group_split(class) %>%
  map_dfr(
    ~st_sample(
      ., 
      size=500, 
      type="random", 
      exact=TRUE) %>% 
      st_coordinates(.) %>%
      as.data.frame, 
    .id="class")

# Extract values from raster
samples <-raster::extract(shet_r, training_df %>% dplyr::select(X,Y)) %>%
  bind_cols(.,class = training_df$class) %>%
  na.omit
```

```{r load_landscape_samples, message=FALSE, warning=FALSE, include=FALSE}
# Load output from 
samples <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/samples")
```


### Habitiat classification training data

In order to classify improved grassland, four other distinctive and closely associated habitat types were classified: unimproved grassland, crops, bare peatland and upland. A number of areas representative of each habitat type were selected as can be seen in Figure \@ref(fig:habitatTraining). 

```{r habitatTraining, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=1.2, fig.cap='Habitat classification training areas'}
training_classes <- st_read("~/Documents/GitHub/shetlandwaders/data/training_data_classification/Training_samples.shp", crs=27700, quiet = TRUE)
p <- ggplot() + RStoolbox::ggRGB(img = shet_r,
                      r = 4,
                      g = 3,
                      b = 2,
                      alpha = 0.2,
                      stretch = 'lin', 
                      ggLayer = T) +
#xlim(e[1:2]) + ylim(e[3:4]) +
geom_sf(alpha = 0.8, aes(col=Habitat, fill = Habitat), data = training_classes) 
p
```

### Sampling of habitat training classes

Each habitat training dataset was randomly sampled in order to train a support vector machine classifier. Distributions for the sampled data for each training set are shown in Figure \@ref(fig:plotSampleDistributions). The NIR and red vegetation spectra appear to be the most distinct across different habitat types. 

```{r plotSampleDistributions, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.cap='Sampled distributions for each training class, from the Sentinel 2 dataset of the Shetland landmass'}
#Pivot sample data to make easier to plot probability density
samples %>% 
  pivot_longer(cols=c(aerosol:veg_red4), names_to = "Sensor") %>%
  mutate(habitat = case_when(
    class == 1 ~ "Improved",
    class == 2 ~ "Unimproved",
    class == 3 ~ "Upland",
    class == 4 ~ "Bare peat",
    class == 5 ~ "Crop",
    class == 6 ~"Cliff")) %>%
  ggplot() +
  geom_density(aes(x=value, group = habitat, col = habitat)) +
  facet_wrap(~Sensor, scales = "free", ncol = 3) +
  theme_bw()

```
### Support vector machine classifier training

The SVM was trained to classify the five target habitat classes so that improved grassland can be separated and used as a covariate in wader response modelling.

```{r train_svm, warning=FALSE, message=FALSE, include=FALSE}
#Set for reproducibility
set.seed(123)
# Split training/testing 3:1
# Use class as sampling strata
data_split <- samples %>% initial_split(prop=0.7,strata = class)

# Create data frames for the two sets:
train_data <- training(data_split)
test_data  <- testing(data_split)
```


```{r preprocess, , message=FALSE, warning=FALSE, include=FALSE}
# Create preprocessing recipe
preprocessing_recipe <- 
  recipes::recipe(class ~ ., data = train_data) %>%
  recipes::step_mutate(class = as.factor(class)) %>%
  prep()
```


```{r cv_fold, warning=FALSE, , message=FALSE, include=FALSE}
# Create 10 folds (resamples)
set.seed(123)
sent_cv_folds <- 
  recipes::bake(
    preprocessing_recipe, 
    new_data = train_data
  ) %>%  
  rsample::vfold_cv(v = 10)
```


```{r spec_model, message=FALSE, warning=FALSE, include=FALSE}
# specify classification engine - radial svm
svm_model <-
  parsnip::svm_rbf(
    cost = tune(),
    rbf_sigma = tune()
  ) %>%
  set_engine("kernlab") %>%
  set_mode("classification")
```


```{r svm_search_params,message=FALSE, warning=FALSE, include=FALSE}
# search grid specification
svm_params <-
  dials::parameters(
    cost(),
    rbf_sigma()
  )
```

### Search grid parameterisation

The SVM parameters used to create a number of different models are shown in Table \@ref(tab:searchGrid).

```{r searchGrid, echo=FALSE, message=FALSE, warning=FALSE}

svm_grid <- expand.grid(rbf_sigma=seq(from = 0.11, to = 0.13, by = 0.01), 
                         cost=seq(from = 18, to = 20, by = 1))
# knit table
svm_grid %>%
  knitr::kable(
    align = c('l','l'),
    col.names = c("RBF sigma","Cost"),
    booktabs = TRUE,
    caption = 'Search parameters used for model fitting of support vector machine'
    )
```


```{r wflow, message=FALSE, warning=FALSE, include=FALSE}
# tidymodel workflows package to add a formula to our svm model specification.
svm_wf <- 
  workflows::workflow() %>%
  add_model(svm_model) %>% 
  add_formula(class ~ .)
```


```{r tune_model, eval=FALSE, warning=FALSE, , message=FALSE, include=FALSE}
# hyperparameter tuning of the model
svm_tuned <- tune::tune_grid(
  object = svm_wf,
  resamples = sent_cv_folds,
  grid = svm_grid,
  metrics = yardstick::metric_set(accuracy, kap),
  control = tune::control_grid(verbose = TRUE)
)
```

### Best model results by root mean squared error

The best SVM model parameters, as measured by classification accuracy, are shown in Table \@ref(tab:modelResults). Root-mean squared error (RMSE) was used to select the best fitting model. 

```{r modelResults, echo=FALSE, message=FALSE, warning=FALSE}
#Load cached output of previous chunk
svm_tuned <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/svm_tuned")
# Generate metrics
svm_tuned %>% tune::show_best(metric = "accuracy") %>% 
  dplyr::select(cost,rbf_sigma, mean,std_err) %>%
  # knit table
  knitr::kable(
    col.names = c("Cost","RBF sigma","Accuracy", "se"),
    booktabs = TRUE,
    caption = 'SVM model parameters from best fitting models'
  )
```

Figure \@ref(fig:viewMetrics) shows the parameters associated with each model fit and the resulting rmse used in the 10-fold cross validation against the trading data. 

```{r viewMetrics, echo=FALSE, message=FALSE, warning=FALSE,fig.align='center', fig.cap='RMSE for each model fit, as a function of model parameters `mtry` cost and `rbf_sigma`'}

svm_best_params <- svm_tuned %>% tune::select_best("accuracy")

# Plot the results
library(data.table)
svm_tuned %>% collect_metrics() %>% 
  dplyr::select(mean,cost:rbf_sigma) %>% data.table() %>% 
  melt(id="mean") %>% 
  ggplot(aes(y=mean,x=value,colour=variable)) + 
  geom_point(show.legend = FALSE) + 
  facet_wrap(variable~. , scales="free") + theme_bw() +
  labs(y="Accuracy", x = "Parameter")
```


```{r final_model, message=FALSE, warning=FALSE, include=FALSE}
# Finalize the svm model to use the best tuning parameters
svm_model_final <- svm_model %>% finalize_model(svm_best_params)
```

### Model performance using test dataset

A training data set was tested against the best model fit. The results of classifier accuracy are shown in Table \@ref(tab:evalPerf).

```{r evalPerf, echo=FALSE, message=FALSE, warning=FALSE}
# First evaluat on the training data
train_processed <- bake(preprocessing_recipe,  new_data = train_data)

train_prediction <- svm_model_final %>%
  # fit the model on all the training data
  fit(
    formula = class ~ ., 
    data    = train_processed
  ) %>%
  # predict the class for the training data
  predict(new_data = train_processed) %>%
  bind_cols(train_data)

# Make class a factor
train_prediction$class <- as.factor(train_prediction$class)

svm_score_train <- train_prediction %>%
  yardstick::metrics(class, .pred_class) 

# And now on the test data
test_processed <-  bake(preprocessing_recipe,  new_data = test_data)

test_prediction <- svm_model_final %>%
  # fit the model on all the training data
  fit(
    formula = class ~ ., 
    data    = train_processed
  ) %>%
  # use the training model fit to predict the test data
  predict(new_data = test_processed) %>%
  bind_cols(test_data)

# Make class a factor
test_prediction$class <- as.factor(test_prediction$class)

svm_score_test <- test_prediction %>%
  yardstick::metrics(class, .pred_class) 

# knit table
svm_score_test %>%
  dplyr::select(.metric, .estimate) %>%
  knitr::kable(
    align = c('l','l'),
    col.names = c("Metric","Estimate"),
    booktabs = TRUE,
    caption = 'Classifier performance using test data set'
  )

```

The confusion matrix in Figure \@ref(fig:confusionMatrix) shows the results of the model prediction for each habitat class against thsoe of the test data set. The most incorrectly classified habitat is improved grassland versus crop, followed by Upland versus Bare Peatland. Both of these inaccuracies are not significant to the objective of producing an overall classification for improved grassland, in that crop habitat is often reseeded impproved grassland.

```{r confusionMatrix, echo=FALSE, message=TRUE, warning=TRUE, fig.align = 'center', fig.cap='Confusion Matrix from classificaton of test dataset'}
# Confusion matrix
cm<-test_prediction %>% yardstick::conf_mat(truth=class,estimate=.pred_class) 
autoplot(cm, type = "heatmap") 
```


```{r classify_raster, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Now take the final model and apply to overall raster that is to be classified
# Bake sent raster
sent_df <- shet_r %>% as.data.frame()
sent_df[is.na(sent_df)] <- 0

pred <- svm_model_final %>% 
  fit(formula = class ~.,
      data=train_processed) %>% 
  predict(new_data = sent_df) 

# Create result raster
res_r <- raster(shet_r)
res_r <- setValues(res_r,pred$.pred_class)
```

### Classification across all Shetland habitat

The best fit model was then used across the raster dataset for all of Shetland, to enable classification of all habitat. The results are shown in \@ref(fig:plotPredictionShet). The improved grassland and crop habitat is predominantly in the south of the island. It can be seen that the main middle island, Yell, is predominantly upland and bare peat.

```{r genRasterOfResults, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Use text for legend


tar<-levels(res_r)[[1]]
tar[["landcover"]]<-my_legend
levels(res_r) <- tar

# load shetland IACS polygons
shet_iacs_sp <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/shet_iacs_sp")
final_res_r <- raster::mask(res_r,shet_iacs_sp)
```

```{r plotPredictionShet, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=1.2, fig.cap='Classification of Shetland habitat in order to determine the location of improved grassland'}
# Load cached results to plot
final_res_r <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/final_res_r")

# Use text for legend
my_legend <- c('improved',
            'unimproved',
            'upland',
            'bare peat',
            'crop',
            'cliff'
            )

# Custom colours for fill
my_col = c('orange','green','blue','brown','yellow','red')
plot(final_res_r, 
     legend=FALSE,
     col=my_col)
legend("right", legend=my_legend,fill=my_col)
```