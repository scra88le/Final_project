```{r load_libs_for_imp_grassland, message=FALSE, warning=FALSE, include=FALSE}
library(sf)
library(raster)
library(tidymodels)
library(tidyverse)
library(RStoolbox)
```

## Improved grassland classification

The results below detail how remotely sensed satellite data was processed using the Support Vector Machine (SVM) machine learning algorithm to generate a classification for improved grassland across Shetland.

### Shetland Sentinel 2 satelitte dataset

A Sentinel 2 Level 2A spatial dataset was clipped using the Integrated Administration And Control System (IACS) [@Oesterle2003-zb] field boundary shapefile for Shetland. This gave a spatial dataset comprising of land-based habitat only, excluding built areas and roads. The RGB composite of the clipped image is shown in Figure \@ref(fig:plotSentRGB)  

```{r loadSentinelImg, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# 2020 July Product
sent = list.files("~/Documents/GitHub/shetlandwaders/data/shetland_sentinel/", 
                  pattern = ".tiff", 
                  full.names = TRUE)
# Create raster stack
sent = stack(sent)

# Sentinel 2 Bands, central wavelength(micrometre), all at 10m resolution
sat_bands <- c('aerosol',   # Band 1 - Coastal aerosol (0.443)
               'blue',      # Band 2 - Blue (0.490)
               'green',     # Band 3 - Green (0.560)
               'red',       # Band 4 - Red (0.665)
               'veg_red1',  # Band 5 - Vegetation Red Edge (0.705)    
               'veg_red2',  # Band 6 - Vegetation Red Edge (0.740)
               'veg_red3',  # Band 7 - Vegetation Red Edge (0.783)
               'NIR',       # Band 8 - NIR (0.842)
               'veg_red4',  # Band 8A - Vegetation Red Edge (0.865)
               'SWIR1',     # Band 11 - SWIR1 (1.610)
               'SWIR2')     # Band 12 - SWIR 2 (2.190)

# Name the layers
names(sent) <- sat_bands
# Convert to brick for faster processing
sent <- brick(sent)

# Projection for 27700 (OSGB) - this takes a long time!
osgb36_proj <- "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs"
sent <- projectRaster(sent, crs=osgb36_proj)
# Get raster extent
e <- raster::extent(sent)

# Load IACS field boundaries
iacs_sf <- st_read("~/Documents/GitHub/shetlandwaders/data/IACS_Shetland/IACS_Shetland_polygon.shp",quiet=TRUE) 
iacs_sp <- as_Spatial(iacs_sf)
# Crop the iacs field boundaries to the raster extent
shet_iacs_sp <- crop(iacs_sp,e)
# Mask out all habitat not covered by the cropped iacs polygons 
shet_r <- raster::mask(sent, shet_iacs_sp)

```

```{r plotSentRGB, echo=FALSE, message=FALSE, warning=FALSE,fig.align='center', fig.asp=1.2, fig.cap='Clipped Sentinel 2 RGB composite of Shetland'}
# Load processed sentinel image
shet_r <- stack("~/Documents/GitHub/shetlandwaders/data/cacheddata/shet_raster.grd")
  # Plot Sentinel RGB image
RStoolbox::ggRGB(img = shet_r,
      r = 4,
      g = 3,
      b = 2,
      stretch = 'lin')
```


```{r load_land_categories, eval=FALSE, warning=FALSE, include=FALSE}
set.seed(123)
training_df <- st_read("~/Documents/GitHub/shetlandwaders/data/training_data_classification/Training_samples.shp",crs=27700, quiet=TRUE) %>%
  mutate(class = case_when(
    Habitat == "Improved"    ~ 1,
    Habitat == "Unimproved"  ~ 2,
    Habitat == "Upland"      ~ 3,
    Habitat == "Bare peat"   ~ 4,
    Habitat == "Crop"        ~ 5,
    Habitat == "Cliff"       ~ 6)
    ) %>%
  # Dump the columns we dont need
  dplyr::select(-Id, -Habitat) %>%
  # Sample 100 points from each class
  group_split(class) %>%
  map_dfr(
    ~st_sample(
      ., 
      size=500, 
      type="random", 
      exact=TRUE) %>% 
      st_coordinates(.) %>%
      as.data.frame, 
    .id="class")

# Extract values from raster
samples <-raster::extract(shet_r, training_df %>% dplyr::select(X,Y)) %>%
  bind_cols(.,class = training_df$class) %>%
  na.omit
```

```{r load_landscape_samples, message=FALSE, warning=FALSE, include=FALSE}
# Load output from 
samples <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/samples")
```

### Habitiat classification training data

In order to classify improved grassland, five other distinctive habitat types were also classified: unimproved grassland, crops, bare peat, cliffs and upland. A number of areas representative of each habitat type were selected as shown in Figure \@ref(fig:habitatTraining). 

```{r habitatTraining, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=1.2, fig.cap='Habitat classification training areas'}
training_classes <- st_read("~/Documents/GitHub/shetlandwaders/data/training_data_classification/Training_samples.shp", crs=27700, quiet = TRUE)
p <- ggplot() + RStoolbox::ggRGB(img = shet_r,
                      r = 4,
                      g = 3,
                      b = 2,
                      alpha = 0.2,
                      stretch = 'lin', 
                      ggLayer = T) +
#xlim(e[1:2]) + ylim(e[3:4]) +
geom_sf(alpha = 0.8, aes(col=Habitat, fill = Habitat), data = training_classes) 
p
```

### Sampling of habitat training classes

Each habitat training dataset was randomly sampled in order to train the SVM habitat classifier. Distributions for the sampled data for each training set are shown in Figure \@ref(fig:plotSampleDistributions). 

```{r plotSampleDistributions, echo=FALSE, message=FALSE, warning=FALSE, fig.asp = 1, fig.width=10, fig.align='center', fig.cap='Sampled distributions for each training class, from the Sentinel-2 Level 2A dataset of the Shetland archipelago'}
#Pivot sample data to make easier to plot probability density
samples %>% 
  pivot_longer(cols=c(aerosol:SWIR2), names_to = "sensor") %>%
  mutate(habitat = case_when(
    class == 1 ~ "Improved",
    class == 2 ~ "Unimproved",
    class == 3 ~ "Upland",
    class == 4 ~ "Bare peat",
    class == 5 ~ "Crop",
    class == 6 ~ "Cliff")) %>%
  ggplot() +
  geom_density(aes(x=value, group = sensor, col = sensor)) +
  facet_wrap(~habitat, scales = "free", ncol = 3) +
  theme_bw()

```

There are a number of distinguishing observations that can be made from Figure \@ref(fig:plotSampleDistributions). Firstly a visual inspection of the bare peat, cliff, upland and crop classes show a clearly different spectral finger-print for each habitat type. Perhaps unsurprisingly improved and unimproved grassland are relatively similar. On closer inspection it can be seen that the shape of the near infra-red (NIR) spectral histogram appears significantly different for improved grassland. A significant proportion of NIR light is reflected by green vegetation, therefore greener "improved" vegetation is likely to have a strong NIR spectral response [@Pettorelli2014-ad].   

### Support vector machine classifier training

In order to undertake supervised training of an SVM, optimal values for for so-called *hyper-parameters* must be selected. The type of SVM tuned for classifying improved grassland was a radial basis SVM, and two key hyper-parameters must be tuned for when selecting the best model fit. A so-called *search grid* is used to specify all permutations of hyper-parameters that will be utilised to find the optimum fit. For the improved grassland classification, the specific search parameters used are shown in Table \@ref(tab:searchGrid).

```{r train_svm, warning=FALSE, message=FALSE, include=FALSE}
#Set for reproducibility
set.seed(123)
# Split training/testing 3:1
# Use class as sampling strata
data_split <- samples %>% initial_split(prop=0.7,strata = class)

# Create data frames for the two sets:
train_data <- training(data_split)
test_data  <- testing(data_split)
```


```{r preprocess, , message=FALSE, warning=FALSE, include=FALSE}
# Create preprocessing recipe
preprocessing_recipe <- 
  recipes::recipe(class ~ ., data = train_data) %>%
  recipes::step_mutate(class = as.factor(class)) %>%
  prep()
```


```{r cv_fold, warning=FALSE, , message=FALSE, include=FALSE}
# Create 10 folds (resamples)
set.seed(123)
sent_cv_folds <- 
  recipes::bake(
    preprocessing_recipe, 
    new_data = train_data
  ) %>%  
  rsample::vfold_cv(v = 10)
```


```{r spec_model, message=FALSE, warning=FALSE, include=FALSE}
# specify classification engine - radial svm
svm_model <-
  parsnip::svm_rbf(
    cost = tune(),
    rbf_sigma = tune()
  ) %>%
  set_engine("kernlab") %>%
  set_mode("classification")
```


```{r svm_search_params,message=FALSE, warning=FALSE, include=FALSE}
# search grid specification
svm_params <-
  dials::parameters(
    cost(),
    rbf_sigma()
  )
```


```{r searchGrid, echo=FALSE, message=FALSE, warning=FALSE}

svm_grid <- expand.grid(rbf_sigma=seq(from = 0.11, to = 0.13, by = 0.01), 
                         cost=seq(from = 18, to = 20, by = 1))
# knit table
svm_grid %>%
  knitr::kable(
    align = c('l','l'),
    col.names = c("RBF sigma","Cost"),
    booktabs = TRUE,
    caption = 'Search parameters used for model fitting of support vector machine'
    )
```


```{r wflow, message=FALSE, warning=FALSE, include=FALSE}
# tidymodel workflows package to add a formula to our svm model specification.
svm_wf <- 
  workflows::workflow() %>%
  add_model(svm_model) %>% 
  add_formula(class ~ .)
```


```{r tune_model, eval=FALSE, warning=FALSE, , message=FALSE, include=FALSE}
# hyperparameter tuning of the model
svm_tuned <- tune::tune_grid(
  object = svm_wf,
  resamples = sent_cv_folds,
  grid = svm_grid,
  metrics = yardstick::metric_set(accuracy, kap),
  control = tune::control_grid(verbose = TRUE)
)
```

### Best model results by classification accuracy

The best SVM model hyper-parameters, as measured by classification accuracy, are shown in Table \@ref(tab:modelResults). It can be seen that when the best model is used to make classification predictions using the training, it achieved an accuracy of 82% with a standard error of 1%.

```{r modelResults, echo=FALSE, message=FALSE, warning=FALSE}
#Load cached output of previous chunk
svm_tuned <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/svm_tuned")
# Generate metrics
svm_tuned %>% tune::show_best(metric = "accuracy") %>% 
  dplyr::select(cost,rbf_sigma, mean, std_err) %>%
  # knit table
  knitr::kable(
    col.names = c("Cost","RBF sigma","Accuracy", "se"),
    booktabs = TRUE,
    caption = 'SVM model parameters from best fitting models'
  )
```


```{r viewMetrics, message=FALSE, warning=FALSE, include=FALSE}

svm_best_params <- svm_tuned %>% tune::select_best("accuracy")

# Plot the results
#library(data.table)
#svm_tuned %>% collect_metrics() %>% 
#  dplyr::select(mean,cost:rbf_sigma) %>% data.table() %>% 
#  melt(id="mean") %>% 
#  ggplot(aes(y=mean,x=value,colour=variable)) + 
#  geom_point(show.legend = FALSE) + 
#  facet_wrap(variable~. , scales="free") + theme_bw() +
#  labs(y="Accuracy", x = "Parameter")

```


```{r final_model, message=FALSE, warning=FALSE, include=FALSE}
# Finalize the svm model to use the best tuning parameters
svm_model_final <- svm_model %>% finalize_model(svm_best_params)
```

### Model performance using the test dataset

Having selected the best model fit, the same model was used to make predictions against the test dataset. The SVM classifier accuracy was shown to be 85% as shown in Table \@ref(tab:evalPerf).

```{r evalPerf, echo=FALSE, message=FALSE, warning=FALSE}
# First evaluat on the training data
train_processed <- bake(preprocessing_recipe,  new_data = train_data)

train_prediction <- svm_model_final %>%
  # fit the model on all the training data
  fit(
    formula = class ~ ., 
    data    = train_processed
  ) %>%
  # predict the class for the training data
  predict(new_data = train_processed) %>%
  bind_cols(train_data)

# Make class a factor
train_prediction$class <- as.factor(train_prediction$class)

svm_score_train <- train_prediction %>%
  yardstick::metrics(class, .pred_class) 

# And now on the test data
test_processed <-  bake(preprocessing_recipe,  new_data = test_data)

test_prediction <- svm_model_final %>%
  # fit the model on all the training data
  fit(
    formula = class ~ ., 
    data    = train_processed
  ) %>%
  # use the training model fit to predict the test data
  predict(new_data = test_processed) %>%
  bind_cols(test_data)

# Make class a factor
test_prediction$class <- as.factor(test_prediction$class)

svm_score_test <- test_prediction %>%
  yardstick::metrics(class, .pred_class) 

# knit table
svm_score_test %>%
  dplyr::select(.metric, .estimate) %>%
  knitr::kable(
    align = c('l','l'),
    col.names = c("Metric","Estimate"),
    booktabs = TRUE,
    caption = 'Classifier performance using test data set'
  )

```

The confusion matrix in Figure \@ref(fig:confusionMatrix) shows the results of the model prediction for each habitat class against those of the test data set. The most incorrectly classified habitat is unimproved grassland (class 2) versus upland (class 3), followed by improved grassland (class 1) versus unimproved grassland. This gives an accuracy for improved grassland classification of c.85% over the test dataset.

```{r confusionMatrix, echo=FALSE, message=TRUE, warning=TRUE, fig.align = 'center', fig.cap='Confusion Matrix from classificaton of test dataset'}
# Confusion matrix
cm<-test_prediction %>% yardstick::conf_mat(truth=class,estimate=.pred_class) 
autoplot(cm, type = "heatmap") 
```


```{r classify_raster, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Now take the final model and apply to overall raster that is to be classified
# Bake sent raster
sent_df <- shet_r %>% as.data.frame()
sent_df[is.na(sent_df)] <- 0

pred <- svm_model_final %>% 
  fit(formula = class ~.,
      data=train_processed) %>% 
  predict(new_data = sent_df) 

# Create result raster
res_r <- raster(shet_r)
res_r <- setValues(res_r,pred$.pred_class)
```

### Classification across all Shetland habitat

The best fitting model was used across the entire raster dataset for Shetland, to enable classification of all habitat according to the chosen six habitat classes. The results are shown in \@ref(fig:plotPredictionShet). It can be seen that the improved grassland and crop habitat classes are predominantly in the south of the islands; this was validated by a local expert. It can be seen that the main middle island, Yell, is predominantly upland and bare peat.

```{r genRasterOfResults, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Use text for legend


tar<-levels(res_r)[[1]]
tar[["landcover"]]<-my_legend
levels(res_r) <- tar

# load shetland IACS polygons
shet_iacs_sp <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/shet_iacs_sp")
final_res_r <- raster::mask(res_r,shet_iacs_sp)
```

```{r plotPredictionShet, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.asp=1.2, fig.cap='Classification of Shetland habitat in order to determine the location of improved grassland'}
# Load cached results to plot
final_res_r <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/final_res_r")

# Use text for legend
my_legend <- c('improved',
            'unimproved',
            'upland',
            'bare peat',
            'crop',
            'cliff'
            )

# Custom colours for fill
my_col = c('orange','green','blue','brown','yellow','red')
plot(final_res_r, 
     legend=FALSE,
     col=my_col)
legend("right", legend=my_legend,fill=my_col)
```