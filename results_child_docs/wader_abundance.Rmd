## Wader abundance trends

A random forest regression model was used to fit abundance response, given a set of 10 environmental covariates. The number of trees in the model hyper-parameters was set to 1000, and the number of predictors sampled at each split (`mtry`) together the minimum number of data points that cause a node to split furthter (`min_n`) were tuned using a search grid containing ten points in the hyper plane.

```{r load_libs_abund, include=FALSE}
library(tidymodels)
library(tidyverse)
library(sf)
```

<!-- 
Code to generate Random Forest regression model to estimate 
population abundance for each wader species.

Method is as follows:

1 - Load data and generate suitable format
2 - Split into training and test data sets
3 - Preprocess data
-->

```{r load_species_data, message=FALSE, warning=FALSE, include=FALSE}
# load BBS data for all species and years
curlew        <- readxl::read_xlsx("~/Documents/GitHub/shetlandwaders/data/bbs_species_data/Curlew.xlsx", col_names = T)
lapwing       <- readxl::read_xlsx("~/Documents/GitHub/shetlandwaders/data/bbs_species_data/Lapwing.xlsx", col_names = T)
oystercatcher <- readxl::read_xlsx("~/Documents/GitHub/shetlandwaders/data/bbs_species_data/oystercatcher.xlsx", col_names = T)
redshank      <- readxl::read_xlsx("~/Documents/GitHub/shetlandwaders/data/bbs_species_data/Redshank.xlsx", col_names = T)
snipe         <- readxl::read_xlsx("~/Documents/GitHub/shetlandwaders/data/bbs_species_data/Snipe.xlsx", col_names = T)

# join all BBS data into one dataframe
bbs_df <- rbind(curlew,
                lapwing,
                oystercatcher,
                redshank,
                snipe)

# Now pivot into long format, and clean up data that have no breeding observations or did not have a survey.
bbs_df <- bbs_df %>%
  # We aren't interested in non-breeding birds that are present.
  mutate_if(is.character, ~ifelse(.=="P", 0, .)) %>%
  mutate_if(is.character, ~ifelse(.=="p", 0, .)) %>%
  # Mainland observations only
  filter(str_detect(PLAN_NO,"^HU") | str_detect(PLAN_NO, "^HP")) %>%
  # Pivot data into long format
  pivot_longer(cols = c(`2002`:`2019`), names_to = "Year", values_to = "Count") %>%
  # Change type for number columns
  mutate_at(.vars = c("Year", "Count"), ~as.numeric(.)) %>%
  # Any count with NA means no survey
  na.omit()

#load covariate data
covars_sf <- readRDS("~/Documents/GitHub/shetlandwaders/data/covars_df") %>%
  st_centroid() %>% 
  cbind(., sf::st_coordinates(.)) 

# Add centroid for each sqaure
covars_df <- covars_sf %>% 
    st_drop_geometry()

# Create Waders data from for all observation data
wader_covars_df <- left_join(bbs_df, covars_df, by="PLAN_NO") %>%
  na.omit()

# Create adjust count to take account of bbs square area and species detectability
detect_df <- data.frame(
  Species = c("OC", "L", "RK", "CU", "SN"),
  d = c(0.803, # oystercatcher 
        0.723, # lapwing
        0.667, # redshank
        0.831, # curlew
        0.723 # snipe
        )) 

# Join detectability
wader_covars_df <- wader_covars_df %>% left_join(detect_df)
# Adjust count
wader_covars_df <- wader_covars_df %>% 
  mutate(Count = Count*area/(1000*1000*d))

# Get rid of all covars that are not needed for population modelling
wader_covars_df <- wader_covars_df %>% 
  dplyr::select(Species, Year, Count, elev, D, E, `F`, wgt_pH, wgt_orgCarbon,AWC, dist_sea, bare_pc_cvr, imp_gr_pc_df,X,Y)

```

```{r data_sampling, message=FALSE, warning=FALSE, include=FALSE}
# Split data between analysis and assess - 60%/40%
set.seed(123)
species_df <- wader_covars_df %>% 
  nest(-Species) %>% 
  mutate(split       = map(.x = data,  ~initial_split(.x, prop=0.6)),
         sp_training = map(.x = split, ~training(.x)),
         sp_testing  = map(.x = split, ~testing(.x)))

# Create recipe for pre-processing of data. Apply a recipe to the training data whereby:
# * Removes covariates that have large absolute correlations with other covariates
# * Normalize numeric data to have a mean of zero
# * Normalize numeric data to have a standard deviation of one
species_df <- species_df %>%
  mutate(recipe = map(
    .x=sp_training,
    ~recipe(.x, Count ~.) %>%
      # Remove covariates that are 80% correlated
      step_corr(all_predictors(), threshold = 0.8) %>%   
      step_center(all_predictors(), -all_outcomes()) %>%
      step_scale(all_predictors(), -all_outcomes()))) 
```

<!-- Create a model specification for a random forest where we will tune mtry (the number of predictors to sample at each split) and min_n (the number of observations needed to keep splitting nodes). -->

```{r tune_spec, message=FALSE, warning=FALSE, include=FALSE}
# Set-up a specification for tuning - same for each training dataset
tune_spec <- rand_forest(
  mtry = tune(),
  trees = 1000,
  min_n = tune()
  ) %>%
  set_mode("regression") %>%
  set_engine("ranger",keep.inbag=T)

# Put it all together in a workflow
species_df <- species_df %>%
  mutate(
    tune_wf = map(
      .x = recipe,
      ~workflow() %>% 
         add_recipe(.x) %>% 
         add_model(tune_spec)))
```

<!-- Now we can tune the hyperparameters for a random forest model. First, letâ€™s create a set of cross-validation resamples to use for tuning. Then run a model for each sample dataset. -->

```{r hyperparam_tuning, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Create x10 cross-validation resamples for each species dataset
set.seed(234)
species_df <- species_df %>%
  mutate(
    sp_folds = map(
      .x=sp_training,
      # Use 5-fold valdiation
      ~vfold_cv(.x, v=5)))

# Run the workflow
set.seed(345)
species_df <- species_df %>%
  mutate(
    tune_res = map2(
      .x=tune_wf,
      .y=sp_folds,
      # Generate models for tuning
      ~tune_grid(
        .x,
        resamples=.y,
        # Choose 10 random points in the tune grid
        grid=10)))

```

### Tuning model  hyper parameters

The tuning grid over 10 different folds gave the results for the different hyper parameter permutations as shown in Figure \@ref(fig:showTuneResults) - each figure show the results for a particular species. Each parameter is plotted against the resulting root mean squared error (rmse). 

```{r showTuneResults, message=FALSE, warning=FALSE, echo=FALSE, fig.align='center', fig.asp= 0.8, fig.cap='Root mean squared evaluation of hyper parameters across all species'}
# Load cached results from initial tuning
species_df <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/abun_ml_1")
# Generate metrics for each species tuning run
# Then map into plots of tuning parameter ranges
species_df <- species_df %>% 
  mutate(tune_plot=map2(
    .x=tune_res,
    .y=Species,
    ~collect_metrics(.x) %>%
      filter(.metric == "rmse") %>%
      dplyr::select(mean, min_n, mtry) %>%
      pivot_longer(min_n:mtry,
        values_to = "value",
        names_to = "parameter") %>%
      # Map to plots
      ggplot(aes(value, mean, color = parameter)) +
             geom_point(show.legend = FALSE) +
             facet_wrap(~parameter, scales = "free_x") +
             # Add Species name to each plot
             labs(title = .y, x = NULL, y = "rmse")))

# Plot the results
species_df$tune_plot      

# Drop the plot data column
species_df <- species_df %>% dplyr::select(-tune_plot)
```

### Further model hyper parameter tuning

The model fit was refined further by searching over a revised hypergrid range for each species. The range used was that which gave the lowest rmse as given in Figure \@ref(fig:showTuneResults). The results of the revised tuning grid can be seen in Figure \@ref(fig:plotRetuneResults).

<!-- Now refine the tuning per species -->

```{r reg_grid_tune, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Redshank tuning grid
RK_grid <- grid_regular(
  mtry(range = c(7, 9)),
  min_n(range = c(1, 10)),
  levels = 5)

# Curlew tuning grid
CU_grid <- grid_regular(
  mtry(range = c(3, 6)),
  min_n(range = c(5, 12)),
  levels = 5)

# Oystercatcher tuning grid
OC_grid <- grid_regular(
  mtry(range = c(3, 9)),
  min_n(range = c(1, 10)),
  levels = 5)

# Lapwing tuning grid
L_grid <- grid_regular(
  mtry(range = c(3, 6)),
  min_n(range = c(1, 4)),
  levels = 5)

# Snipe tuning grid
SN_grid <- grid_regular(
  mtry(range = c(2, 4)),
  min_n(range = c(5, 10)),
  levels = 5)

species_grids <- list(CU_grid,
                      L_grid,
                      OC_grid,
                      RK_grid,
                      SN_grid)

#Now try a more targeted tuning process
set.seed(456)
species_df <- species_df %>% mutate(
  retune_res = pmap(
    list(
      tw=tune_wf,
      re=sp_folds,
      gr=species_grids), 
    function(tw,re,gr){
      tune_grid(tw,resamples=re,grid=gr)
    }))
```


```{r plotRetuneResults, echo=FALSE, message=FALSE, warning=FALSE}
# Load cached retune results 
species_df <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/abun_ml_2")
# Plot results
# Then map into plots of tuning parameter ranges
species_df <-species_df %>% 
  mutate(retune_plot=map2(
    .x=retune_res,
    .y=Species,
    ~collect_metrics(.x) %>%
      filter(.metric == "rmse") %>%
      mutate(min_n = factor(min_n)) %>%
      # Map to plots
      ggplot(aes(x=mtry, y=mean, color = min_n)) +
         geom_line(alpha = 0.5, size = 1.5) +
         geom_point() +
         labs(title=.y, y = "rmse")))

# Plot parameters of returned models
species_df$retune_plot
# Choose the best model
```

From the plot above we can see which hyper parameters give the best fit, when using root mean squared error as an evaluation metric. It can be seen that the model fit for Snipe has the largest RMSE and Redshank, the lowest. For each species the minimum rmse given by the best model fit, together with the associated hyper parameters (`trees`= 1000 for all models) is shown in Table \@ref(tab:bestByRMSE).

```{r bestByRMSE, echo=FALSE, message=FALSE, warning=FALSE, fig.cap='Lowest RMSE for each species model fit, together with the associated hyper parameters'}
species_df$retune_res %>% 
  map_dfr(~collect_metrics(.x)%>%
  filter(.metric =="rmse") %>%
  arrange(.$mean) %>%
    head(1)) %>%
  bind_cols(Species = species_df$Species, .) %>%
  dplyr::select(Species, mtry, min_n, mean) %>%
    knitr::kable(
    col.names = c("Species","mtry","min_n","rmse"),
    booktabs = TRUE
  )


# Select the best model for each species
species_df <- species_df %>%
  mutate(best_rmse = map(
    .x=retune_res,
    ~select_best(.x,"rmse")),
    final_rf = map(
      .x=best_rmse,
      ~finalize_model(tune_spec, .x)))
```

### Variable importance in model fit

Having selected the best model fit the variable importance for each species was assessed. The `r` `vip` package can be used to explore the relative importance of different covariates in the model fit. The results are shown in Figure \@ref(fig:variableImportance).

```{r variableImportance, echo=FALSE, fig.cap='Variable importance in model fit', message=FALSE, warning=FALSE}
# Load variable importance
library(vip)

# Map over dataset to generate variable importance per species
set.seed(11122)
species_df <- species_df %>%
  mutate(vip_plots=pmap(
    list(rf=final_rf,
         r=recipe,
         s=Species),
    function(rf,r,s){
    rf %>% 
      set_engine("ranger",importance = "permutation") %>%
      fit(Count~., prep(r) %>% juice()) %>% 
      # Plot using the VIP library
      vip(geom="point") +
        ggtitle(s) +
        theme_bw()
      })) 

species_df$vip_plots
```

It can be seen that pH, X (longitude) and grassland percentage coverage for a given OS 1km square are the most important covariates for predicting abundance in Curlew. For Lapwing, pH, heathland percentage coverage and topsoil organic carbon content are the most important variables. Whilst for Oystercatcher, grassland and heathland percentage cover are almost equivalent in their importance followed by longitude. For Redshank and Snipe, available water capacity and heathland are the most important covariates in predicting abundance.


```{r final_fit, message=FALSE, warning=FALSE, include=FALSE}
# Generate final workflow
species_df <- species_df %>%
  mutate(final_wf=map2(
    .x=final_rf,
    .y=recipe,
    ~workflow() %>% 
      add_recipe(.y) %>% 
      add_model(.x)))

# Fit the final model to the training data
species_df <- species_df %>%
  mutate(fit = map2(
    .x=final_wf,
    .y=sp_training,
    ~fit(.x,.y)))
```

### Generate population estimate over time

The random forest regression model was used to predict species abundance over *all* (n=3992) Shetland BBS 1km squares. The model gave a mean estimate together with lower and upper confidence intervals (5% and 95% percentiles respectively), across every year the survey was run (2002 to 2019). The results are shown in Table \@ref(tab:abundanceResults) and plotted Figure \@ref(fig:plotAbunResults)

```{r calcAbundanceResults, eval=FALSE, fig.cap='Breeding wader population abundance', message=FALSE, warning=FALSE, include=FALSE}
# Create new dataframe to store results
results_df <- expand.grid(
  Species = c("CU","L","OC","RK","SN"),
  Year = seq(2002,2019,1))

results_df <- species_df %>% 
  dplyr::select(Species,fit) %>% 
  left_join(results_df, by="Species")

# Function to calculate the population for a given year
# and a given set of covariates
calc_annual_pop <- function(m, d, y){
  pop = predict(m, d) %>% sum()
  ci  = predict(m, type="conf_int", d) %>% as_tibble()
  out <- list(Pop=pop,
              l_ci = ci %>% pluck(".pred_lower") %>% sum,
              u_ci = ci %>% pluck(".pred_upper") %>% sum)
  return(out)
}


# Calculate population by year, across all species
results_df <- results_df %>% 
  mutate(pop = map2_df(
    .x=Year,
    .y=fit,
    ~calc_annual_pop(.y, 
                     covars_df %>% 
                     na.omit %>% 
                     bind_cols(Count=NA, Year=.x), .x))) 
```




```{r plotAbunResults,echo=FALSE, message=FALSE, warning=FALSE, fig.align='centre', fig.cap='Shetland breeding wader abundance by year'}
# Load cached abundance data
results_df <- readRDS("~/Documents/GitHub/shetlandwaders/data/cacheddata/abun_results")
# Plot species population curves
results_df %>%
  ggplot(aes(y=pop$Pop,x=Year)) +
  geom_line(color='#00aaff') +
  geom_ribbon(aes(ymin = pop$l_ci, ymax=pop$u_ci), fill='gray90') +
  geom_line(color='#00aaff') +
  ylim(0,10000) +
  labs(y = "Abundance", x = "Year") +
  facet_wrap(~Species, ncol = 3, scales = "free_y") +
  theme_minimal()
```
Across the years 2002 to 2019 the abundance of breeding waders across all species appear to have decreased, with the exception of Snipe. The most significant decline was breeding Lapwing abundance. Note that the confidence intervals for Snipe are highly variable in certain years. Table \@ref(tab:popChgTable) shows the change in breeding wader abundance by species between 2002 and 2019.

```{r popChgTable, echo=FALSE,  message=FALSE, warning=FALSE, fig.cap='Change in breeding wader abundance across all species, between the years 2002 and 2019'}
popChgTable <- data.frame(
  species = c("CU","L","OC","RK","SN"),
  y2002   = c(4597, 3474, 5269, 2390, 6043),
  y2019   = c(4088, 2638, 4760, 2248, 7391))

popChgTable$chg <- ((popChgTable$y2019 - popChgTable$y2002)/popChgTable$y2002 * 100) %>% round(1)

popChgTable %>% 
    knitr::kable(
    col.names = c("Species","2002","2019","% Change"),
    booktabs = TRUE)
```

### Lapwing abundance association with grassland holdings

Data from 2002 to 2017 for grassland holdings in hectares categorised as: tillage, grassland less than five years old (reseeded grassland), grassland five years or greater and private grazing were tested for normality, and found to be log-normally distributed. A linear regression was plotted for Lapwing abundance versus each grassland categorisation (in Hectares) as shown in Figure \@ref(fig:lapwingGrasslandPlot).

```{r loadAgdata, message=FALSE, warning=FALSE, include=FALSE}
# Load data
agri_df <- readxl::read_xlsx("~/Documents/GitHub/shetlandwaders/data/agri_census.xlsx", col_names = T)
wader_pop_df <- results_df %>% dplyr::select(-fit)

# Fix missing data - straight line impute
agri_df$tillage[[10]] <- (agri_df$tillage[[9]] - agri_df$tillage[[11]])/2 + agri_df$tillage[[11]]
agri_df$grass_lt_5_y[[10]] <- (agri_df$grass_lt_5_y[[9]] - agri_df$grass_lt_5_y[[11]])/2 + agri_df$grass_lt_5_y[[11]]
agri_df$grass_gt_5_y[[10]] <- (agri_df$grass_gt_5_y[[9]] - agri_df$grass_gt_5_y[[11]])/2 + agri_df$grass_gt_5_y[[11]]
agri_df$private_grazing[[10]] <- (agri_df$private_grazing[[9]] - agri_df$private_grazing[[11]])/2 + agri_df$private_grazing[[11]]
agri_df <- agri_df %>% dplyr::select(-common_grazing)

# join agri and population data
joined_df <- results_df %>%
  dplyr::select(Year, Species) %>% 
  bind_cols(wader_pop_df$pop) %>%
  dplyr::select(Species, Year, Pop) %>%
  left_join(.,agri_df, by=c("Year"="year"))
```


```{r lapwingGrasslandPlot, echo=FALSE, message=FALSE, warning=FALSE, fig.asp = 1.1, fig.cap="Association between the size of grassland categories on Shetland and Lapwing population abundance"}
# Select Lapwing only
lapwing_df <- joined_df %>% 
  na.omit %>%
  pivot_longer(cols=tillage:private_grazing,
               names_to = "crop", 
               values_to = "hectares") %>% 
  filter(Species == "L") %>%
  mutate(crop = case_when(
    crop == "tillage" ~ "Tillage",
    crop == "grass_lt_5_y" ~ "Grass < 5y",
    crop == "grass_gt_5_y" ~ "Grsss >= 5y",
    crop == "private_grazing" ~ "Private grazing"
  ))

# Plot linear regression association between Lapwing abundance and hectares for each
# grassland category.
lapwing_df %>%
  ggplot(aes(x=hectares, y=Pop)) +
  geom_point() + 
  geom_smooth(method = "lm", formula = y~x) +
  facet_wrap(~crop, scales = "free", ncol=2) +
  theme_minimal()
```
Figure \@ref(fig:lapwingGrasslandPlot) show's that Lapwing population size is clearly positively associated with the size of grassland that is less than five years old (that grassland which has been reseeded) and tillage (land prepared for spring crops). Futhermore, Figure \@ref(fig:lapwingGrasslandPlot) shows that Lapwing population abundance is negatively associated with grassland that is not reseeded (Grass >= 5y).

The `r` package `gamlss`  was used to fit a log-normal model for Lapwing population abundance with grassland less than 5 years old as a covariate. The grassland < 5 years old was statistically significant covariate (p<0.0001), and the residuals of the model were approximately normally distributed as shown in Figure \@ref(fig:fitLapwingModel).

```{r fitLapwingModel, echo=FALSE, message=FALSE, warning=FALSE}
# Load library
library(gamlss)
# Fit model
m1 <- gamlss(Pop~hectares, 
             family = LOGNO(),
             # Look at L population for grassland <5 years
             data= lapwing_df %>% filter(crop == "Grass < 5y"))
# Plot the model information
plot(m1)  
```

### Spatial abundance distriution

The abundance prediction created above is spatial and so can be plotted to show how species abundance is spatially distributed across Shetland. Figure \@ref(fig:spatialDistributions) shows abundance distribution for each species in 2019. 

```{r spatialDistributions, echo=FALSE, message=FALSE, warning=FALSE,fig.height=5, fig.align='center', fig.cap='Spatial abundance distribution of breeding waders for 2002 and 2019'}
# Generate species abundance distribution data structure
sad <- results_df %>% dplyr::select(Species,fit,Year)
# Covariates over Shetland landmass only
bbs_covars <- covars_sf %>% 
  na.omit 

# Now for each model make a density prediction for each BBS square
plots_df <- pmap_df(
  list(s=sad$Species, y=sad$Year, m=sad$fit),
  function(s,y,m){
    p <- predict(
      m, 
      cbind(bbs_covars, Year=y))
    # Create structure to return dta
    l <- tibble(species=s, year =y, p, X = bbs_covars$X, Y = bbs_covars$Y)
    return(l)
    }
  ) 

# Plot the species abundance distribution.
# Here we plot 2019 only
library(viridis)
plots_df %>% filter(year == 2019) %>%
      ggplot() +
      geom_tile(aes(x=X, y=Y, fill=.pred, width = 1000, height = 1000)) +
      coord_equal() +
      labs(fill="Density") +
      #scale_fill_distiller(palette = "Spectral") +
      scale_fill_viridis_c(trans = "sqrt") +
      theme_minimal() +
      facet_grid(~species) +
      theme(axis.text = element_blank(),
            axis.title = element_blank(),
            panel.grid = element_blank())

```

### Net abundance change by species between 2002 and 2019

Given the spatial abundance distribution for 2002 and 2019, it is possible to plot the net change in breeding wader abudnance between the two years. This is shown in Figure \@ref(fig:netChgPlot).

```{r netChgPlot, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.cap='Change in breeding wader density (count/km2)',fig.height=5}
plots_df %>%
  filter(year %in% c(2002,2019)) %>%
  pivot_wider(names_from = c(year), values_from = c(.pred)) %>%
  mutate(net_chg = `2019`-`2002`) %>%
      ggplot() +
      geom_tile(aes(x=X, y=Y, fill=net_chg, width = 1000, height = 1000)) +
      coord_equal() +
      labs(fill="Density Chg") +
      scale_fill_gradient2() +
      #scale_fill_distiller(palette = "Spectral") +
      theme_minimal() +
      facet_grid(~species) +
      theme(axis.text = element_blank(),
            axis.title = element_blank(),
            panel.grid = element_blank()) 

```

It can be seen that the drop in abundance as shown in Table \@ref(tab:popChgTable) is reflected in the net change plots. Significant increases for Snipe, but significant Lapwing density declines in the south mainland, and Oystercatcher across Unst and Fetlar.
